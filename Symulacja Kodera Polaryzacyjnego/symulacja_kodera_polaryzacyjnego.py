# -*- coding: utf-8 -*-
"""Symulacja Kodera Polaryzacyjnego

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hxdGFSxbrEzSY1CwVrgvmR_LQUag-ThY

# **Koder polaryzacjny**
Maciej Niedźwiecki, 147973
"""

import random
import numpy as np

### WPROWADZANIE DANYCH PRZEZ UŻYTKOWNIKA ###

# Wprowadzenie długości wektora wejściowego, konwersja na int, testowanie wprowadzonej wartości
# n2 - rozmiar macierzy
# n  - długość wektora

while True:
    n2 = int(input("Podaj rozmiar macierzy (8, 16, 32): "))
    if n2 in [8, 16, 32]:
      break
    print("Nieprawidłowa długość. Spróbuj ponownie.")

n = int(n2 / 2)

decision = input("Czy chcesz wprowadzić wektor? (TAK - wprowadź, NIE - wygeneruj losowy): ").lower()

if decision == "tak":
    while True:
      # Dzielenie ciągu na części (spacja) i tworzenie listy elementów
      u = input(f"Wprowadź wektor wejściowy o długości {n} (format: 1 0 1 1): ").split()
      if len(u) == n and all(bit in ['0', '1'] for bit in u):
        # Konwersja każdego elementu listy z łańcucha znaków na liczbę całkowitą
        u = [int(bit) for bit in u]
        print(f"\nWprowadzony wektor wejściowy u: {u}")
        break
      print(f"Nieprawidłowe dane, wektor powinien zawierać {n} bitów i składać się z 0 i 1. Spróbuj ponownie.")
else:
    u = [random.randint(0, 1) for i in range(n)]
    print(f"\nWygenerowany losowy wektor wejściowy o długości {n}: {u}")


### WYMAZYWANIE ###

#(8, 4)
#Frozen: 1 2 3 5

#(16,10)
#Frozen: 1, 2, 3, 5, 9, 4

if n == 4:
    print(f"\nWymazywane bity: 1 2 3")
elif n == 8:
    print(f"\nWymazywane bity: 1 2 3 5")
else:
    print(f"\nWymazywane bity: 1, 2, 3, 5, 9, 4")

u_erased_x = []

# Reprezentacja zamrażania wg. Arikana
for i in range(0, len(u)):
    if n == 4:
        if i in [0, 1, 2]:
            u_erased_x.append('?')
        else:
            u_erased_x.append(int(u[i]))
    if n == 8:
        if i in [0, 1, 2, 4]:
            u_erased_x.append('?')
        else:
            u_erased_x.append(int(u[i]))
    if n == 16:
        if i in [0, 1, 2, 4, 8, 3]:
            u_erased_x.append('?')
        else:
            u_erased_x.append(int(u[i]))

# Wyświetlanie zamrażania w sposób graficzny '?'
print(f"Wymazywanie Arikana: {u_erased_x}")


u_erased = []

# Zamiana '?' na '0'
for i in range(0, len(u_erased_x)):
    if u_erased_x[i] == '?':
        u_erased.append(0)  # Zamiana '?' na '0'
    else:
        u_erased.append(u_erased_x[i])

print(f"Wymazany wektor: {u_erased}")

u_erased_0 = []

for i in range(n2):
    if i < len(u_erased):
        u_erased_0.append(u_erased[i])
    else:
        u_erased_0.append(0)

print(f"Przedłużony wektor: {u_erased_0}")


### KODOWANIE ###
### MACIERZE KRONECKERA ###

# Macierz Arikana
F2 = np.array([[1, 0], [1, 1]])

# Obliczanie produktu Kroneckera dwóch macierzy
def kronecker_product(A, B):
    return np.kron(A, B)

# Generowanie macierzy Kroneckera
def generate_kronecker_matrices(F2):
    F4 = kronecker_product(F2, F2)
    F8 = kronecker_product(F4, F2)
    F16 = kronecker_product(F8, F2)
    F32 = kronecker_product(F16, F2)
    return F4, F8, F16, F32

# Generowanie macierzy F2, F4, F8, F16, F32
F4, F8, F16, F32 = generate_kronecker_matrices(F2)

kronecker_matrices = {
    4: F4,
    8: F8,
    16: F16,
    32: F32,
}

print(f"\nWykorzystywana macierz Kroneckera F{n2}:\n{kronecker_matrices[n2]}")
#print("F4:\n", F4) #F4, F8, F16, F32

### OPERACJA KODOWANIA ###

# Mnożenie macierzy
u_coded = kronecker_matrices[n2] @ u_erased_0

# Wykonanie operacji mod 2
for i in range(0, len(u_coded)):
    u_coded[i] = u_coded[i]%2

print(f"\nZakodowany wektor: {u_coded}")


### DEKODOWANIE ###

inverse_kronecker_matrix = np.linalg.inv(kronecker_matrices[n2])
inverse_kronecker_matrix = inverse_kronecker_matrix.astype(int)
print(f"\nOdwrotna macierz Kroneckera F{n2}:\n{inverse_kronecker_matrix}")

inverse_kronecker_matrix = (inverse_kronecker_matrix % 2 + 2) % 2
print(f"Wykorzystywana odwrotna macierz Kroneckera (F{n2} mod 2):\n{inverse_kronecker_matrix}")

u_decoded = inverse_kronecker_matrix @ u_coded
u_decoded = (u_decoded % 2 + 2) % 2

print(f"\nZdekodowany wektor: {u_decoded}")

u_decoded_erased_x = []

# Reprezentacja zamrażania wg. Arikana
for i in range(0, len(u)):
    if n == 4:
        if i in [0, 1, 2]:
            u_decoded_erased_x.append('?')
        else:
            u_decoded_erased_x.append(int(u[i]))
    if n == 8:
        if i in [0, 1, 2, 4]:
            u_decoded_erased_x.append('?')
        else:
            u_decoded_erased_x.append(int(u[i]))
    if n == 16:
        if i in [0, 1, 2, 4, 8, 3]:
            u_decoded_erased_x.append('?')
        else:
            u_decoded_erased_x.append(int(u[i]))

print(f"Wymazywanie Arikana: {u_decoded_erased_x}")

u_decoded_erased = []

# Zamiana '?' na '0'
for i in range(0, len(u_decoded_erased_x)):
    if u_decoded_erased_x[i] == '?':
        u_decoded_erased.append(0)  # Zamiana '?' na '0'
    else:
        u_decoded_erased.append(u_decoded_erased_x[i])

print(f"Wymazany wektor: {u_decoded_erased}")


### PODSUMOWANIE KODERA I DEKODERA ###

print(f"\n\nPODSUMOWANIE:"
      f"\nWektor wejściowy: {u}"
      #f"\nWymazywanie Arikana: {u_erased_x}"
      f"\nWymazany wektor: {u_erased}"
      #f"\nPrzedłużony wektor: {u_erased_0}"
      f"\n\nZakodowany wektor: {u_coded}"
      f"\nZdekodowany wektor: {u_decoded}"
      #f"\n\nWymazywanie Arikana: {u_decoded_erased_x}"
      f"\n\nWymazany wektor: {u_decoded_erased}"
      )